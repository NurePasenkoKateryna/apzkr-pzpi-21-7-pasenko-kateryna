Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система організації та керування музичними гуртами та оркестрами

Студентка гр. ПЗПІ-21-7	_____________ Пасенко К.Є.
(підпис)
Керівник роботи	_____________ ст. викл. Сокорчук І.П.
(підпис)
	Роботу захищено «__»________ 2024 р. з оцінкою ________________________
	
Комісія:	_____________ доц. Лещинський В.О.
      (підпис)
	_____________ доц. Лещинська І.О.
         (підпис)
	_____________ ст. викл. Сокорчук І.П.
         (підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук      Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення		
Курс                     3                     Семестр 	                  6 		
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ 
НА КУРСОВУ РОБОТИ СТУДЕНТОВІ  

                                          Пасенко Катерині Євгеніївні				
1. Тема проєкту: «Програмна система організації та керування музичними гуртами та оркестрами» 								
2. Термін узгодження завдання курсової роботи: «  25  » березня	 2024 р.
3. Термін здачі студентом закінченої роботи: «       »                        2024 р.  
4. Вихідні дані до проекту: В програмній системі передбачити: додавання нового гурту, подій, жанрів, редагування подій, гуртів, експортування даних, придбання квитків. Використовувати OC Windows 10, СКБД MongoDB, середовище розробки JetBrains WebStorm						
5. Зміст пояснювальної записки (перелік питань, що належить розробити):
вступ, аналіз предметної області, постановка задачі, проектування  програмного проекту, структура бази даних, кодування програмного  проекту, опис розробленої програмної системи, висновки, перелік посилань,  додатки											
6. Перелік графічного матеріалу (з точними зазначенням обов’язкових креслень):схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки					



КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проєкту	25.03.2024	виконано
2	Проєктування програмного проєкту	31.03.2024	виконано
3	Кодування програмного проєкту	12.04.2024	виконано
4	Оформлення пояснювальної записки	01.05.2024	виконано
5	Захист курсової роботи		не виконано

Дата видачі завдання «13» березня 2024 р.

Керівник	_____________ ст. викл. Сокорчук І.П.
            (підпис)
Завдання прийняла до виконання ст. гр. ПЗПІ-21-7	
_____________ Пасенко К. Є.
           (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 103 с., 39 рис., 3 табл., 3 додатки, 6 джерел.
МУЗИКАЛЬНИЙ ГУРТ, ПОДІЯ, КВИТОК, ПРОГРАМНА СИСТЕМА, КОРИСТУВАЧ, АДМІНІСТРАТОР.

Об’єктом дослідження є музикальна індустрія, а саме актуальне на сьогоднішній день питання щодо організації та керування музикальними гуртами та оркестрами, їх подіями та інформацією про них.
Метою курсової роботи є розробка системи, яка дозволяє створювати та редагувати інформацію про гурти, події та музичні жанри, експортувати інформацію, придбати квиток на певну подію, відсканувати QR-код та відобразити отриману інформацію, додавати членів гурту та видаляти їх, створювати певні місця для події та редагувати їх.
Методи розробки базуються на платформі NodeJS з використанням мови програмування JavaScript та фреймворку ExpressJS, реляційної бази даних MongoDB, веб-додаток базується на бібліотеці React в поєднанні з вищезгаданою мовою програмування JavaScript, смарт-пристрій для сканування QR-коду було розроблено за допомогою інструменту Node-RED, який дозволяє використовувати різні відкриті бібліотеки і базується на платформі NodeJS.
У результаті роботи створено програмну реалізацію системи для організації та керуванням музичними гуртами та оркестрами. Програмна система складається з веб-додатку, сервера та смарт-пристрою.
 
ЗМІСТ


ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1	Бізнес-вимоги	9
1.1.1 Бізнес-можливості	9
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2	Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна фукнціональність	13
1.2.3 Припущення та залежності	13
1.3	Рамки та обмеження проєкту	14
1.3.1 Рамки первинного випуску	14
1.3.2 Рамки наступних випусків	16
1.3.3 Обмеження та вийнятки	16
1.4 Бізнес-контекст	17
1.4.1 Профілі зацікавлених сторін	17
1.4.2 Пріорітети проєкту	19
1.4.3 Робоче середовище	20
2	ПОСТАНОВКА ЗАДАЧІ	22
3	ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	23
3.1	Проєктування серверної частини	23
3.1.1 Моделювання програмної системи серверної частини	23
3.1.2 Проектування бази даних	24
3.1.3 Технології та архітектурні рішення	26
3.1.4 Специфікація REST	28
3.2	Проєктування IoT-частини	32
3.2.1	Моделювання програмної системи смарт-пристрою	32
3.2.2	Діаграма взаємодії для IoT-частини програмної системи	33
3.2.3	Діаграма діяльності для IoT-частини програмної системи	34
3.2.4	Діаграма пакетів для IoT-частини програмної системи	34
3.2.5	Розробка IoT-частини програмної системи	35
3.3	Проєктування клієнтської частини програмної системи	36
3.3.1	Діаграма компонентів для клієнтської частини програмної системи	36
3.3.2	Діаграма станів для клієнтської частини програмної системи	37
3.3.3	Діаграма пакетів для клієнтської частини програмної системи	39
3.3.4	Розробка клієнтської частини програмної системи	40
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ	42
4.1 Запуск застосунку	42
4.2 Реалізація програмної системи	44
4.2.1 Вигляд програмної системи для користувача	44
4.2.2 Вигляд програмної системи для адміністратора	52
ВИСНОВКИ	61
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	62
ДОДАТОК А	63
А.1 Код файлу app.js	63
А.2 Код файлу, який містить маршрути для експорту даних export.js	65
А.3 Код файлу, який містить маршрути для реєстрації та авторизації користувача authorization.js	68
А.4 Код маршруту для придбання квитку tickets.js	70
А.5 Код маршруту для створення місця для певної події seats.js	72
ДОДАТОК Б	74
Б.1 Код файлу node-red-qr-code-scanner-flows.json	74
ДОДАТОК В	80
В.1 Код файлу сторінки профіля користувача UserProfile.js	80
В.2 Код файлу сторінки відображення події EventPage.js	88
В.3 Код сторінки покупки квитка PurchaseTicketPage.js	93
В.4 Код файлу відображення шапки сайту Header.js	101


 
ВСТУП


У сучасному світі музика відіграє надзвичайно важливу роль у культурному та розважальному житті суспільства, сприяючи формуванню та зміцненню міжособистісних зв'язків, розвитку та вираженню емоцій, а також надихаючи та піднімаючи настрій аудиторії. Музичні гурти та оркестри виступають ключовими учасниками цього процесу, створюючи неповторні музичні композиції та виступаючи на різноманітних подіях – від концертів та фестивалів до корпоративних заходів та приватних вечірок.
Проте, організація та керування музичними гуртами та оркестрами є складним завданням, яке вимагає системного та професійного підходу. На шляху до успішної реалізації концертних заходів, гастрольних турів та інших музичних проектів стикаються з різноманітними викликами, такими як координація репетицій, управління фінансами, планування маршрутів гастролей, а також просування та реклама.
Відсутність систематизованого та ефективного підходу до цих аспектів може призвести до збитків, втрати потенційних можливостей та зниження якості виступів. Тому виникає необхідність у створенні програмної системи, яка б допомогла музичним гуртам та оркестрам ефективно керувати всіма аспектами їхньої діяльності, починаючи від планування репетицій і закінчуючи аналізом результатів виступів.
Така програмна система має на меті спростити та оптимізувати рутинні процеси, пов'язані з організацією та управлінням музичними гуртами та оркестрами, забезпечуючи керівникам та адміністраторам зручний інструмент для планування робочих графіків, контролю учасників гурту.
Все це дозволить підвищити ефективність та конкурентоспроможність музичних колективів, забезпечуючи їм можливість зосередитися на творчому процесі та досягненні нових висот у своїй мистецькій діяльності. 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1 Бізнес-можливості


У сфері управління музичними гуртами та оркестрами відомими конкурентами є платформи для організації та просування подій, такі як Bandsintown та Songkick. 
Bandsintown відзначається своїм глобальним покриттям, що сприяє привертанню аудиторії з різних куточків світу, та зручним інструментарієм для організації концертів. Однак, відмічаються обмеження функціоналу для музикантів та платні послуги.
Songkick, зі свого боку, вирізняється можливістю продажу квитків на події через платформу та розширеним функціоналом для організаторів. Проте, його обмежене географічне покриття та високі комісійні можуть стати перешкодою для привертання аудиторії та оптимізації витрат.
Програмна система, яку ми плануємо розробити для управління музичними гуртами та оркестрами, має на меті вирішити ці недоліки:
-	глобальне покриття без обмежень;
-	розширений функціонал для користувачів та адміністраторів;
-	оптимізований процес продажу квитків;
-	зручний інтерфейс та мобільність.


1.1.2 Бізнес-цілі та критерії успіху


ВО-1: Залучення користувачів до користування преміум-функціями платформи та збільшення прибутку з преміум-планів.
ВО-2: Підвищення обсягу продажу квитків на 25% кожний квартал після запуску системи.
ВО-3: Підняття показників задоволеності користувачів на 15% завдяки зворотному зв’язку та впровадженню нововведень.
SC-1: Кожного місяця кількість зареєстрованих користувачів має збільшуватися в два рази.
SC-2: За рік роботи системи щомісячний прибуток повинен підвищитися на 20%. 
SC-3: Залучення не менше 5 партнерів на рік для розміщення реклами на платформі та збільшення обсягу рекламних прибутків на 20% щорічно.


1.1.3 Потреби клієнтів або ринку


Всього у системи є два види користувачів – це сам бізнес та клієнти, які будуть з ним взаємодіяти.
Потребами для клієнтів є:
-	зручний та інтуїтивно зрозумілий дизайн;
-	зворотній зв’язок;
-	зручне проведення оплати;
-	відстеження актуальних концертів.
Потребами для бізнесу є:
-	проста та зрозуміла для використання система;
-	безпека даних;
-	можливість розширення клієнтської бази;
-	можливість відслідковувати взаємодію користувачів з системою.


1.1.4 Бізнес-ризики


У контексті програмної системи організації та керування музичними гуртами та оркестрами, існують певні бізнес-ризики, які варто враховувати при розробці та впровадженні системи. 
Першим серйозним ризиком є конкуренція з боку існуючих платформ, таких як Bandsintown та Songkick, які також надають послуги організації музичних подій та концертів. Ці платформи вже мають свою аудиторію та розроблену інфраструктуру, що може зробити їх привабливими для використання як для музикантів, так і для шанувальників музики.
Другим ризиком є можливі технічні проблеми, такі як системні збої або порушення безпеки даних. Це може призвести до недоступності системи для користувачів або втрати конфіденційної інформації. Запобігання цим проблемам вимагає впровадження надійних систем моніторингу та захисту даних.
Третім ризиком є економічні фактори, такі як зміни на ринку та економічна нестабільність. Зниження покупної спроможності або зміни у споживчому попиті можуть вплинути на прибутковість та використання системи.
Для мінімізації цих ризиків необхідно провести детальний аналіз конкурентного середовища та ринкових тенденцій, розробити ефективні механізми захисту даних та безпеки системи, а також розробити гнучку стратегію управління економічними ризиками. Тільки шляхом виваженого підходу до управління цими ризиками можна забезпечити успішну реалізацію програмної системи організації та керування музичними гуртами та оркестрами.


1.2	Концепція рішення
1.2.1 Окреслення концепції


Метою даного проекту є створення сучасної та зручної програмної системи для організації та керування діяльністю музичних гуртів та оркестрів, що дозволить забезпечити ефективне та зручне управління всіма аспектами їхньої діяльності.
Користувачі системи матимуть можливість легко знаходити та реєструватися на музичні заходи, переглядаючи актуальний розклад виступів музичних гуртів та оркестрів, переглядати інформацію про улюблених виконавців. Вони також зможуть придбати квитки на концерт і переглянути їх у власному профілі.
Організаторам надається можливість ефективно керувати своїми виступами, можуть редагувати або створювати гурти. Вони можуть створювати події, вказуючи всю необхідну інформацію про виступ та редагувати її.
Важливим аспектом системи є забезпечення безпеки користувачів та організаторів. Вона використовує сучасні технології шифрування для захисту конфіденційності даних та постійно відслідковуються для вчасного реагування на можливі інциденти. Крім того, система пропонує зручний сервіс підтримки для вирішення будь-яких запитань чи проблем користувачів.
Така програмна система буде сприяти підвищенню продуктивності та ефективності роботи музичних гуртів та оркестрів, дозволяючи їм зосередитися на творчому процесі та досягненні нових вершин у власній мистецькій діяльності.



1.2.2 Головна фукнціональність

MF-1: Управління складом групи: Додавання та видалення учасників, відстеження їх контактної інформації.
MF-2: Додавання концерту: Організатори можуть створювати нові концерти, додавати інформацію про час, місце проведення та т.п.
MF-3: Реєстрація та купівля: Користувач може створити власний профіль та купувати квитки на виступи.
MF-4: Профіль виконавця: Користувач може переглядати профіль виконавця.
MF-5: Платіжна система: Інтеграція платіжних систем для зручної та безпечної оплати.
MF-7: Редагування та видалення концертів: Організатори мають можливість редагувати інформацію про концерт або видалити її за потреби.
MF-7: Фінансове управління: Ведення бюджету гурту, відстеження витрат на репетиції, концерти та інші витрати.
MF-8: Інтерфейс доступний декількома мовами: Користувач може користуватися застосунком українською або англійською мовами.


1.2.3 Припущення та залежності


П-1: Користувачі та організатори мають доступ до мобільного інтернету або мережі Wi-Fi для використання системи. 
П-2: Програмна система користується достатнім попитом на організацію концертів.
П-3: Організатори та користувачі зацікавлені в користуванні застосунком для організації та керуванням музичними гуртами та оркестрами.
З-1: Реалізація та стабільна робота програмної системи залежить від наявності та якості технічних ресурсів, серверів та мережі.
З-2: Успіх платформи залежить від активності та зацікавленості організаторів та музичних гуртів у використанні системи.
З-3: Безпека та конфіденційність даних користувачів та організаторів визначається використаними технологіями.
З-4: Платформа повинна відповідати місцевим та міжнародним правовим нормам, які відповідають за обробку інформації користувачів.


1.3	Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Програмна система включає в себе чотири частини: серверна, IoT, front-end та мобільна.
Серверна частина (back-end) включатиме в себе:
-	реєстрація та авторизація користувачів: реалізація можливості авторизуватися та реєструватися з підтримкою ролей;
-	створення, редагування та видалення концертів: реалізація функціоналу, який відповідальний за створення, редагування та видалення концертів для організаторів;
-	функціонал оплати: реалізація можливості взаємодії з платіжними сервісами для обробки грошових надходжень;
-	фільтрація концертів: реалізація функціоналу відповідального за фільтрацію концертів при пошуку;
-	створення та редагування профілю виконавця: реалізація функціоналу, який відповідальний за створення та редагування профілю виконавця;
-	збереження даних: реалізація функціоналу відповідального за збереження даних користувачів.
Клієнтська частина (Front-end) включатиме в себе:
-	реєстрація та авторизація користувачів: реалізація сторінок для авторизації та реєстрації користувачів;
-	створення, редагування та видалення концертів: реалізація сторінок для створення, редагування та видалення концертів для організатора;
-	наявність адмін-панелі: реалізація панелі, яка дозволяє керувати користувачами, даними системи, створення резервної копії та експорт і імпорт даних;
-	створення та редагування профілю виконавця: реалізація сторінок для створення та редагування профілю виконавця;
-	локалізація інтерфейсу: реалізація можливості користувачем обрати англійську чи українську мови;
IoT частина включатиме в себе:
-	Wi-Fi модуль: наявність модулю Wi-Fi для передачі даних с датчику на серверну частину для оброблення даних;
-	NFC: застосування NFC-технології для швидкої реєстрації на концертах. 




1.3.2 Рамки наступних випусків


В майбутньому проект буде масштабуватися та буде впроваджено новий функціонал.
Серверна частина (back-end) включатиме в себе:
-	зворотній зв'язок: користувачі зможуть залишати коментарі та виставити оцінку концерту;
-	наявність аналітики: реалізація функціоналу відповідального за аналітику відвідуваності, взаємодії та реакції користувачів на концерті.
Клієнтська частина (Front-end) включатиме в себе:
-	зворотній зв’язок: реалізація можливості користувачам залишати відгуки та виставляти оцінки на сторінці концерту;
 IoT частина включатиме в себе:
-	інтерактивні елементи: використання пристроїв для інтерактивної взаємодії з користувачами під час проведення концертів;
-	GPS: використання GPS технологій для відстеження руху учасників під час концерту.


1.3.3 Обмеження та вийнятки


Обмеження:
-	доступ до інтернету: система передбачає наявність з’єднання з мережею Інтернет для користувачів;
-	технічне обладнання: IoT вимагає сучасного обладнання, що не завжди доступне у користувачів;
-	збір та обробка даних: збір та обробка даних через IoT може спричинити проблеми з конфіденційністю.
Вийнятки:
-	технічні проблеми: технічні проблеми можуть вплинути на використання системи, наприклад, відмова серверу або зараження системи вірусом;
-	надзвичайні обставини: надзвичайні обставини, наприклад, війна чи карантин можуть вплинути на попит використання платформи.
-	політичні обмеження: в разі введення політичних обмежень або змін у законодавстві, що регулює інтернет-послуги, можливе обмеження доступу до платформи для користувачів з певних регіонів або країн.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін наведена в таблиці 1.1

Таблиця 1 – Профілі зацікавлених сторін
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Бізнес	Успішне використання платформи та монетизація	Активно беруть участь в популяризації продукту та забезпеченню стійкого бізнесу	Збільшення користувачів, приріст прибутку	Фінансові обмеження, конкуренція на ринку
Інвестори	Отримання прибутку та максимізація вкладених коштів	Цікавляться успіхом продукту та фінансовими показниками	Приріст прибутку	Втрата інвестицій, коливання ринку
Користувачі платформи	Зручний та доступний продукт для організації та керування музичними гуртами та оркестрами	Очікують зручного інтерфейсу та цікавого функціоналу	Знаходження цікавих концертів, висока якість організації	Доступ до Інтернету, нецікаві концерти
Організатори концертів	Зручний та доступний продукт для організації та керування музичними гуртами та оркестрами	Сприймають платформу як інструмент для просування своїх концертів та виконавців	Збільшення учасників, взаємодія з учасниками	Технічні обмеження, конкуренція між організаторами та виконавцями
Розробники	Учать у створенні інноваційного продукту	Прагнуть до розробки та вдосконалення продукту	Технічна ефективність та підтримка продукту	Обмежені технічні ресурси, терміни проекту

1.4.2 Пріорітети проєкту


Пріорітети проєкту наведені в таблиці 1.2.
Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Версія 1.0 повинна бути випущена до 08.06.2024 р.		Можливе відхилення від графіку на 2 місяці
Функціональність			60-75% функцій повинні бути реалізовані в версії 1.0
Якість			Версія 1.0 повинна пройти 90-95% тестів 
Персонал		Максимальний розмір команди – один розробник та тестувальник	
Ціна		8000 гривень	Допустиме перевищення бюджету на 20% без перегляду робіт


1.4.3 Робоче середовище


З метою зберігання великого обсягу даних та швидкого доступу до них, система буде використовувати базу даних MongoDB. MongoDB є документ-орієнтованою базою даних, що ідеально підходить для систем, що вимагають гнучкості та швидкості в операціях з даними.
З огляду на важливість захисту персональних даних користувачів, система буде дотримуватися вимог регламенту GDPR (Загальний регламент про захист персональних даних), що забезпечить високий рівень конфіденційності та захисту даних користувачів.
Для серверної частини системи буде використана платформа Node.js в поєднанні з Express.js. Node.js є ефективним інструментом для створення високопродуктивних та масштабованих серверних додатків, а Express.js надає зручний інтерфейс для розробки API та взаємодії з ним.
Для розробки IoT частини системи буде використовуватися платформа Arduino з Wi-Fi модулями та NFC. Arduino IDE використовуватиметься для програмування системи мовою програмування С++, що дозволить створити ефективну та надійну систему IoT.
Для фронтенду системи буде використано сучасний стек технологій, такий як HTML, CSS та JavaScript. Фреймворки та бібліотеки, такі як React, допоможуть створити динамічний та інтерактивний користувацький інтерфейс, що забезпечить зручне та ефективне взаємодію з системою.
 
2	ПОСТАНОВКА ЗАДАЧІ


Проаналізувавши предметну область можна зробити висновок, що основною задачею курсової роботи було створення програмної системи для організації та керування музичними гуртами та оркестрами. 
Можна виділити такі основні вимоги програмної системи:
1.	Користувач повинен мати такі можливості:
-	авторизація;
-	реєстрація;
-	перегляд власного профілю;
-	перегляд подій;
-	перегляд гурту;
-	придбання квитка на подію;
-	перегляд придбаних квитків;
-	завантаження QR-коду.
2.	Адміністратор повинен мати такі можливості:
-	авторизація;
-	реєстрація;
-	експортування даних;
-	створення, видалення та редагування події;
-	створення, видалення та редагування гуртів;
-	створення, видалення та редагування жанрів;
-	сканування QR-коду;
 
3	ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
3.1	Проєктування серверної частини
3.1.1 Моделювання програмної системи серверної частини


Користувачі програмної системи поділяються на 2 типи: користувач та адміністратор.
Взаємодію між акторами та системою продемонстровано на діаграмі прецедентів (див. рис. 3.1). 
 
Рисунок 3.1 – Діаграма прецедентів
За допомогою діаграми було визначено список функцій для кожного актора та їх взаємодію з програмною системою. Користувач може:
-	авторизація та реєстрація в системі;
-	перегляд подій;
-	перегляд профілю;
-	редагування профілю;
-	видалення профілю;
-	перегляд придбаних квитків;
-	перегляд гуртів.

Адміністратор згідно діаграми має такий функціонал:
-	авторизація та реєстрація в системі;
-	перегляд профілю;
-	редагування профілю;
-	видалення профілю;
-	перегляд подій;
-	створення, редагування та видалення подій;
-	створення, редагування та видалення гуртів;
-	додавання та видалення учасника гурту;
-	експортування даних.


3.1.2 Проектування бази даних


Проєктування бази даних було проведено за допомогою розробки ER-моделі даних (див. рис. 3.2). Діаграма складається з 8 таблиць: гурти (bands), картки (cards), концертні організатори (concertorganizers), події (events), жанри (genres), місця (seats), квитки (tickets), користувачі (users).
 
Рисунок 3.2 – ER-модель даних
Згідно діаграми можна виділити такі зв’язки між сутностями:
1.	Користувач – Квиток мають зв’язок один до багатьох. У одного користувача може бути багато квитків.
2.	Користувач – Карта мають зв’язок один до багатьох. Користувач може мати багато карт, але карта може мати одного користувача.
3.	Гурт – Жанр мають зв’язок багато до одного. У одного жанру може бути багато гуртів, але гурт має один жанр.
4.	Гурт – Концертний організатор мають зв’язок багато до одного. У гурту може бути один концертний організатор, але у організатора може бути багато гуртів.
5.	Гурт – Подія мають зв’язок один до багатьох. У одного гурта може бути багато подій, але у події приймає участь один гурт.
6.	Гурт – Користувач мають зв’язок один до багатьох. У гурті може бути багато музикантів, але у користувача може бути один гурт.
7.	Подія – Жанр мають зв’язок багато до одного. Подія може належати до одного жанру, але жанр може включати багато подій.
8.	Подія – Місце мають зв’язок багато до одного. У події може бути багато місць, але місце належить одній події.
9.	Квиток – Подія мають зв’язок багато до одного. Квиток пов’язаний з однією подією.
10.	Квиток – Місце мають зв’язок багато до одного. Квиток має одне місце, але місце може мати багато квитків.


3.1.3 Технології та архітектурні рішення


Для розробки серверної частини програмної системи було обрано мову програмування JavaScript з використанням платформи NodeJS та фреймворку ExpressJS.
Для збереження даних було обрано NoSQL базу даних  MongoDB, яка забезпечує гнучкі схеми даних та сумісність з NodeJS. Підключення до бази даних відбувається за допомогою бібліотеки mongoose, яка дозволяє створювати прості схеми для моделювання даних.
Детально використані технології можна побачити на діаграмі розгортання (див. рис. 3.3).
 
Рисунок 3.3 – Діаграма розгортання
Програмна система включає в себе п’ять вузла:
1.	Серверна частина: включає в себе реалізацію бізнес логіки, взаємодії зі смарт-девайсом і роботою з базою даних.
2.	Клієнтська частина: включає в себе реалізацію веб-сторінок з якими взаємодіє користувач, збереження та обробку даних і надсилання запитів на серверну частину.
3.	Смарт-девайс: включає в себе реалізацію датчику для зчитування QR-коду і надсилання отриманих даних на сервер.


3.1.4 Специфікація REST


Даний проєкт містить в собі 31 кінцеву точку з яких складається REST API. Кожна кінцева точка містить в собі функціонал для виконання бізнес логіки.
Специфікація REST для кожної кінцевої точки наведена у таблиці 3.1.
Таблиця 3.1 – Специфікація REST 
Посилання на кінцеву точку	Метод HTTP	Необхідна роль	Опис призначення
/authorization/login	POST	Всі користувачі	Авторизація в обліковому записі
/authorization/registration	POST	Всі користувачі	Реєстрація облікового запису
/band/	GET	Всі користувачі	Отримання інформації про всі гурти
/band/:bandId	GET	Адміністратор	Отримання інформації про певний гурт
/band/create	POST	Адміністратор	Створення гурту
/band/:bandId	PATCH	Адміністратор	Редагування інформації про гурт
/band/:bandId	DELETE	Адміністратор	Видалення певного гурта
/card/create	POST	Користувач	Створення картки
/card/:userId	GET	Користувач	Отримання картки для певного користувача
/event/	GET	Адміністратор	Отримання інформації про всі події
/event/:eventId	GET	Адміністратор	Отримання інформації про певну подію
/event/create	POST	Адміністратор	Створення події
/event/:eventId	PATCH	Адміністратор	Редагування події
/event/:eventId	DELETE	Адміністратор	Видалення події
/export/event	GET	Адміністратор	Експорт даних про всі події
/export/bands	GET	Адміністратор	Експорт даних про всі гурти
/export/users	GET	Адміністратор	Експорт даних про всіх користувачів
/genre/	GET	Всі користувачі	Отримання інформації про всі жанри
/genre/create	POST	Адміністратор	Створення нового жанру
/genre/:genreId	PATCH	Адміністратор	Редагування жанру
/genre/:genreId	DELETE	Адміністратор	Видалення жанру
/seat/:eventId/create	POST	Адміністратор	Створення місця
/seat/:seatId	DELETE	Адміністратор	Видалення місця
/seat/:seatId	PATCH	Адміністратор	Редагування інформації про місто
/seat/:eventId	GET	Адміністратор	Отримання місць для певної події
/ticket/buy	POST	Користувач	Створення квитка
/ticket/:userId	GET	Користувач	Отримання квитків для певного користувача
/user/	GET	Всі користувачі	Отримання інформації про всіх користувачів
/user/:userId	GET	Всі користувачі	Отримання інформації про певного користувача
/user/:userId	PATCH	Всі користувачі	Редагування інформації про користувача
/user/:userId	DELETE	Всі користувачі	Видалення користувача

За допомогою таблиці специфікації REST було визначено кінцеві точки які використовуються для запитів до серверної частини програмної системи.


3.2	Проєктування IoT-частини
3.2.1	Моделювання програмної системи смарт-пристрою


Програмна системи поділяється на 2 ролі: користувач та адміністратор.
Взаємодію користувачів з програмною системою можна побачити на діаграмі прецедентів (див. рис. 3.4).
 
Рисунок 3.4 – Діаграма прецедентів
З даної діаграми можна побачити, що користувач придбає квиток, який містить в собі QR-код. Він може завантажити його. Адміністратор має можливість сканувати QR-код і бачити інформацію, яка міститься всередині.
3.2.2	Діаграма взаємодії для IoT-частини програмної системи


Для подальшої розробки IOT системи було визначено взаємодію системи та IOT девайсу. Цю взаємодію можна побачити за допомогою діаграми взаємодії (див. рис. 3.5).
 
Рисунок 3.5 – Діаграма взаємодії
З діаграми можна побачити, що адміністратор відправляє QR-код до IOT-системи, яка зчитує дані і повертає їх назад до серверу. Якщо все успішно, то адміністратор побачить зчитані дані, якщо ні, то йому відобразиться помилка.
3.2.3	Діаграма діяльності для IoT-частини програмної системи


Щоб визначити процес використання IOT частин в програмній системі було побудовано діаграму діяльності (див. рис. 3.6).
 
Рисунок 3.6 – Діаграма діяльності
Згідно діаграми, коли зчитувач отримує файл, він дешифрує QR-код і відправляє отриманні дані на сервер. Якщо все проходить успішно, то адміністратор бачить дані квитка.


3.2.4	Діаграма пакетів для IoT-частини програмної системи


Для проектування IOT системи було виділено певні пакети. За допомогою діаграми пакетів (див. рис. 3.7) можна побачити структуру і зв’язки між пакетами.
 
Рисунок 3.7 – Діаграма пакетів
З даної діаграми можна виділити такі пункти:
-	HTTP In – пакет, який відповідає за отримання http-запитів від серверу;
-	File Input – пакет, який відповідає за завантаження файлу;
-	Base64 – пакет, який відповідає за конвертацію файлу в формат Base64.
-	HTTP Request – пакет, який відповідає за відправку даних на сервер;
-	Function – пакет, який відповідає за логіку обробки даних.


3.2.5	Розробка IoT-частини програмної системи


Для створення IoT-частини застосунку, було використано інтерфейс Node-RED. 
Для взаємодії з зчитувачем було використано http-вузли, які відправляли запити на сервер. Функція отримує зчитані дані з QR-коду і перетворює їх на формат JSON, які потім відправляє на сервер.
3.3	Проєктування клієнтської частини програмної системи
3.3.1	Діаграма компонентів для клієнтської частини програмної системи


Було виділено наступні компоненти для розробки діаграми компонентів (див. рис. 3.8):
-	Events – відображення подій для користувача та адміністратора;
-	Bands – відображення гуртів для користувача та адміністратора;
-	ExportEvents – експорт всіх подій для адміністратора;
-	ExportBands – експорт всіх гуртів для адміністратора;
-	Tickets – відображення квитків для користувача;
-	QR-code – відображення QR-коду для користувача;
-	QR-codeInfo – відображення інформації з QR-коду для адміністратора.
 Рисунок 3.8 – Діаграма компонентів
Була розроблена діаграма компонентів, яка демонструє архітектуру програмної системи та взаємодію компонентів.
3.3.2	Діаграма станів для клієнтської частини програмної системи


Для розробки клієнтської частини була створено діаграму станів (див. рис. 3.9).
 
Рисунок 3.9 – Діаграма станів

Були виділені такі функції та інтерфейси, які надає клієнтська частина:
-	Форма авторизації: інтерфейс для авторизації користувача;
-	Форма реєстрації: інтерфейс для реєстрації користувача;
-	Профіль користувача: інтерфейс для відображення, редагування, видалення профілю, експорту даних, завантаження та сканування QR-коду;
-	 Управління подіями: інтерфейс для створення, видалення, редагування події та місць;
-	Управління гуртами: інтерфейс для створення, видалення, редагування гурту та додавання та видалення учасників;
-	Купівля квитку: інтерфейс для купівлі квитка.


3.3.3	Діаграма пакетів для клієнтської частини програмної системи


Для структури програмної системи було виділено певні пакети. Зв’язки між даними пакетами можна побачити на діаграмі пакетів (див. рис. 3.10).
 
Рисунок 3.10 – Діаграма пакетів
Згідно діаграми можна побачити, що були виділені такі пакети:
-	Assets – пакет, який містить медіафайли;
-	Styles – пакет, який містить стилі;
-	Public – пакет, який містить файли публічного доступу;
-	Node_module – пакет, який містить сторонні бібліотеки та модулі;
-	Components – пакет, який містить архітектуру веб-сайту.


3.3.4	Розробка клієнтської частини програмної системи

Для розробки клієнтської частини була обрана бібліотека ReactJS. Як інтегроване середовище розробки було використано WebStorm від компанії JetBrains.
Клієнтська частина програмної системи надає графічний інтерфейс для відображення бізнес логіки.
-	Відображення створених подій, можливість їх редагувати та видаляти;
-	Експортування даних: на сторінці профілю адміністратор може обрати кнопки «Експортування …» і обрати потрібний експорт. З’явиться вікно збереження файлу в форматі .xlsx;
-	Відображення створених гуртів, можливість їх редагувати та видаляти, додавати учасників;
-	Покупка квитка: користувач може придбати квиток на потрібну подію;
-	Взаємодія з QR-кодом: користувач може завантажити в своєму профілі QR-код купленого квитка. Адміністратор на сторінці власного профілю може відсканувати QR-код.
Відповідно до вимог захисту даних, паролі користувачів не відображаються при перегляді всієї інформації про користувачів. При авторизації кожен користувач отримує власний токен доступу. Це надає можливість користувачу мати доступи лише до власних даних. 
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
4.1 Запуск застосунку


Щоб запустити застосунок і почати роботу потрібно завантажити архів з репозиторію. Запустити програму WebStorm, або інше середовище розробки, і відкрити в ній папку з відповідним кодом. 
Для запуску серверної частини слід відкрити термінал всередині середовища розробки і ввести команду «node app.js». Якщо ніяких помилок не знайдено, то в терміналі отримаємо повідомлення про успішний запуск серверу (див. рис. 4.1).
 
Рисунок 4.1 – Повідомлення про успішний запуск серверу
Для запуску IoT-пристрою спочатку потрібно встановити Node-Red. Для цього потрібно відкрити консольний рядок і ввести команду «npm install -g --unsafe-perm node-red». Після цього введемо команду «node-red» і якщо все пройшло успішно, то ми побачимо посилання на сайт для роботи зі смарт-пристроєм (див. рис. 4.2). Далі перейшовши на сайт імпортуємо файл формату JSON в якому містяться частини і код для роботи смарт-пристрою (див. рис. 4.3). Натискаємо на кнопку «Deploy» і отримуємо успішне повідомлення про початок роботи IoT-пристрою (див. рис. 4.4).
 
Рисунок 4.2 – Консольний рядок з запущеним Node-RED
 
Рисунок 4.3 – Вигляд інтерфейсу Node-RED з імпортованим кодом
 
Рисунок 4.4 – Повідомлення про успішний запуск IoT-пристрою
Для запуску клієнтської частини переходимо до папки з кодом для клієнтської частини. Відкриваємо термінал всередині середовища розробки і вводимо команду «npm start». Якщо з’явилося повідомлення, що порт 3000 зайнятий (див. рис. 4.5) підтверджуємо зміну порту на 3001 і чекаємо поки сайт запуститься. Якщо все пройшло успішно, то в браузері з’явиться вікно зі сайтом і відобразиться головна сторінка (див. рис. 4.6).
 
Рисунок 4.5 – Повідомлення, що порт 3000 зайнятий
 
Рисунок 4.6 – Головна сторінка сайту


4.2 Реалізація програмної системи
4.2.1 Вигляд програмної системи для користувача

Коли клієнтська частина запуститься, то можна відразу побачити головну сторінку сайту (див. рис. 4.7). Вона складається з шапки сайту, де користувач може перейти на сторінку авторизації (пункт «Логін»), реєстрації (пункт «Реєстрація»), гуртів (пункт «Гурти») та концертів (пункт «Концерти») (див. рис. 4.8). На самій сторінці можна побачити події, які наразі існують. Доступний функціонал пошуку за назвою або гуртом та обрати певний жанр події.
 
Рисунок 4.7 – Головна сторінка сайту
 
Рисунок 4.8 – Шапка сайту
При переході на пункт «Реєстрація» користувач переходить на сторінку реєстрації (див. рис. 4.9). Вона складається з текстових полів: ім’я, прізвище, електронна пошта, номер телефону, пароль та роль і нижче наявна кнопка «Зареєструватися». Якщо користувач ввів невірні дані, наприклад, неправильний формат телефону або паролю, то він отримає помилку (див. рис. 4.10). Якщо всі дані було введено правильно, то користувач потрапляє на сторінку авторизації.

 
Рисунок 4.9 – Сторінка реєстрації користувача
При переході на пункт «Логін» користувач переходить на сторінку авторизації. Вона складається з двох текстових полів: електронна пошта та пароль, нижче знаходить кнопка «Увійти» (див. рис. 4.9). Якщо користувач намагатиметься зайти в обліковий запис залишивши текстові поля пустими, то йому відобразиться помилка (див. рис. 4.10). Якщо пароль або електронна пошта були введені неправильно, то користувач так само побачить помилку (див. рис. 4.11).  Якщо всі дані були правильно введені, то користувач потрапляє на сторінку власного облікового запису.
 
Рисунок 4.9 – Сторінка авторизації користувача
 
Рисунок 4.10 – Помилка, що текстові поля незаповнені
 
Рисунок 4.11 – Помилка, що електронна пошта або пароль введені неправильно
Обліковий запис користувача відображає інформацію, яку користувач ввів при реєстрації: ім’я, прізвище, електронна пошта, мобільний телефон та роль користувача (див. рис. 4.12).

 
Рисунок 4.12 – Обліковий запис користувача
Користувач може редагувати та видаляти обліковий запис. Для редагування слід натиснути на кнопку «Редагувати обліковий запис». Користувач перейде на сторінку редагування облікового запису, де може змінити потрібну інформацію (див. рис. 4.13).
 
Рисунок 4.13 – Редагування облікового запису
Також, користувач може переглянути придбані квитки на певну подію, натиснувши на кнопку «Квитки» і завантажувати їх натиснувши на кнопку «Завантажити QR-код» (див. рис. 4.14).
 
Рисунок 4.14 – Перегляд квитків користувача
Обравши на шапці сайту пункт «Гурти» користувач потрапляє на сторінку з переліком всіх створених гуртів. Є можливість пошуку гурту за назвою та сортування за жанром гурту та організатором. Для того, щоб перейти на сторінку для певного гурту потрібно натиснути на кнопку «Переглянути гурт» (див. рис. 4.15). 
 
Рисунок 4.15 – Сторінка зі всіма гуртами

На сторінці певного гурту можна побачити дану інформацію: назву гурту, жанр, дату формування, опис, учасників гурту (див. рис. 4.16).
 
Рисунок 4.16 – Сторінка певного гурту
Обравши в шапці профілю пункт «Концерти» користувач потрапляє на сторінку всіх подій. На сторінці реалізована можливість пошуку події за назвою, гуртом та локацією і сортування за жанрами. Перейти на сторінку певної події можна натиснувши на кнопку «Переглянути подію» (див. рис. 4.17).
 
Рисунок 4.17 – Сторінка всіх подій
На сторінці певної події відображається певна інформація: назва події, опис, жанр, місце проведення, гурт, дата, кількість місць, самі місця на подію. Наявна кнопка «Купити квиток», яка перенаправляє користувача на сторінку придбання квитка (див. рис. 4.18).
 
Рисунок 4.18 – Сторінка певної події
Сторінка придбання квитка складається з декількох текстових полів: ім’я, прізвище, пошта. Відображається назва події на яку користувач придбає квиток. Наявна можливість обрати певне місце. Якщо користувач немає картки для оплати квитка, то йому надається можливість додати картку (див. рис. 4.19), якщо користувач вже має картку, то він може обрати її зі списку (див. рис. 4.20). Після успішного придбання квитка користувача повертає на обліковий запис, де він може завантажити QR-код з інформацією про квиток.
 
Рисунок 4.19 – Сторінка придбання квитка разом з додаванням картки
 
Рисунок 4.20 – Сторінка придбання квитка вже з наявною карткою


4.2.2 Вигляд програмної системи для адміністратора


Сторінки авторизації та реєстрації для адміністратора залишаються ідентичними до користувача. В обліковому записі адміністратора додаються додаткові кнопки: «Сканування QR-коду», «Експортувати всі події», «Експортувати всіх користувачів» та «Експортувати всі гурти» (див. рис. 4.21).
 
Рисунок 4.21 – Сторінка облікового запису для адміністратора
Кнопка «Сканувати QR-код» відкриває для адміністратора секцію, де він завантажує зображення з QR-кодом користувача, яке було завантажене в обліковому записі користувача. Після успішного сканування смарт-пристроєм на сайті відображається інформацію про квиток (див. рис. 4.22).
 
Рисунок 4.22 – Сторінка сканування QR-коду
Сторінки перегляду гуртів та подій трохи відрізняються від сторінок користувача. Тепер доступна кнопка «Створити подію» (див. рис. 4.23) та «Створити гурт» (див. рис. 4.24).
 
Рисунок 4.23 – Сторінка перегляду подій для адміністратора
 
Рисунок 4.24 – Сторінка відображення гуртів для адміністратора
На сторінці створення події адміністратор вводить таку інформацію: назву, опис, жанр, локацію, гурт, дату проведення події та кількість місць (див. рис. 4.25). Якщо подію успішно створено, то адміністратора перенаправляє на сторінку створеної події.
 
Рисунок 4.25 – Сторінка створення події

На сторінці певної події для адміністратора доступні декілька кнопок: «Редагування події», «Видалення події» та «Створення місця» (див. рис. 4.26).
 
Рисунок 4.26 – Сторінка відображення події для адміністратора
При натисканні на кнопку «Створення місця» відображається форма створення місць. Адміністратор може обрати тип місця і вказати ціну (див. рис. 4.27). Після створення місця адміністратор може редагувати та видаляти місце (див. рис. 4.28).
 
Рисунок 4.27 – Форма створення нового місця
 
Рисунок 4.28 – Відображення сторінки події після додавання місця
На сторінці створення гурту адміністратор може вказати таку інформацію: назву, жанр, організатора, дату створення та опис (див. рис. 4.29). Після успішного створення адміністратора перенаправляє на сторінку всіх гуртів.
 
Рисунок 4.29 – Сторінка створення нового гурту
На сторінці гурту для адміністратора додаються кнопки: «Видалити гурт», «Редагувати гурт» та «Додати учасника» (див. рис. 4.30). Якщо натиснути кнопку «Додати учасника» з’явиться форма вибору користувачів, чия роль є «учасник гурту» (див. рис. 4.31). Після успішного створення учасник відобразиться на сторінці (див. рис. 4.32).
 
Рисунок 4.30 – Сторінка гурту для адміністратора
 
Сторінка 4.31 – Форма додавання учасника в гурт
 
Сторінка 4.32 – Сторінка гурту з доданим учасником
Для адміністратора доступна сторінка з відображенням всіх жанрів. На ній наявна кнопка «Створити жанр» (див. рис. 4.33), яка перенаправляє на форму створення жанру, де адміністратор вказує назву та опис жанру (див. рис. 4.34). Після створення жанру адміністратора перенаправить на сторінку всіх жанрів.
 
Рисунок 4.35 – Сторінка відображення жанрів
 
Рисунок 4.36 – Сторінка створення жанрів
В обліковому записі адміністратор може експортувати певну інформацію (див. рис. 4.37). Для цього йому слід обрати потрібну кнопку і завантажити файл формату Excel. При натисканні кнопки «Експортувати всі події та місця» завантажиться таблиця зі всіма наявними подіями та місцями до них (див. рис. 4.38). При натисканні кнопки «Експортувати всіх користувачів»  завантажиться таблиця зі всіма наявними користувачами (див. рис. 4.39). При натисканні кнопки «Експортувати всі гурти» завантажиться таблиця зі всіма наявними гуртами (див. рис. 4.40).
 
Рисунок 4.37 – Кнопки експорту в обліковому записі адміністратора
 
Рисунок 4.38 – Таблиця Excel з інформацією про гурти та місця
 
Рисунок 4.39 – Таблиця Excel з інформацією про користувачів
 
Рисунок 4.40 – Таблиця Excel з інформацією про гурти
В даному пункті було описано весь наявний функціонал для адміністратора та користувача. Для більш детального відображення функціоналу був створений відеозапис, який відображає роботу програмної системи[6].
 
ВИСНОВКИ


У ході виконання курсової роботи було розроблено програмну систему на тему «Програмна система організації та керування музичними гуртами та оркестрами». 
Було проаналізовано предметну область та створено базу даних. Були реалізовані такі частини програмної системи: серверна, клієнтська та IoT. Дані частини були реалізовані за допомогою платформи NodeJS в поєднанні з фреймворком ExpressJS, бібліотеки React та інтерфейсу для роботи зі смарт-пристроєм Node-RED. 
  Програмна система дозволяє користувачам зручно керувати та організовувати музичні гурти. Вона дозволяє реєструватися та авторизуватися користувачу, керувати інформацією про гурти, події та жанри. Система дозволяє придбати квиток на певну подію і відсканувати його. Крім того, система забезпечує експортування певних даних: всіх подій, користувачів та гуртів.
Була підготовлена пояснювальна записка з детальним описом проектування та реалізації програмної системи, а також функціями для користувачів та адміністраторів.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	ExpressJS. URL: https://expressjs.com (дата звернення 01.06.2024);
2.	Node-RED: documentation. URL: https://nodered.org/docs/ (дата звернення 20.05.2024)
3.	React. URL: https://react.dev (дата звернення 21.05.2024)
4.	NodeJS Api Documentation. URL: https://nodejs.org/docs/latest/api/ (дата звернення 14.05.2024)
5.	 Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 p.(дата звернення 03.06.2024)
6.	Демонстрація курсової роботи. Відеоматеріал. URL: https://youtu.be/3xz4r9IA07c
 
ДОДАТОК А
Програмний код серверної частини


А.1 Код файлу app.js

1 const express = require('express')
2 const mongoose = require('mongoose')
3 const dotenv = require('dotenv')
4 const cors = require('cors')
5 const fileUpload = require('express-fileupload')
6 
7 const genresRouter = require('./routes/genres')
8 const organizationRouter = require('./routes/concertOrganizator')
9 const authorizationRouter = require('./routes/authorization')
10 const userRouter = require('./routes/user')
11 const bandRouter = require('./routes/bands')
12 const eventRouter = require('./routes/events')
13 const seatRouter = require('./routes/seats')
14 const ticketRouter = require('./routes/tickets')
15 const exportRouter = require('./routes/export')
16 const cardRouter = require('./routes/card')
17 
18 dotenv.config()
19 
20 const app = express()
21 const port = process.env.PORT || 3000
22 
23 mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })
24     .then(() => console.log('З\'єднання з базою даних успішне'))
25     .catch(err => console.error('Помилка з\'єднання з базою даних', err))
26 
27 const corsOptions = {
28     origin: 'http://localhost:3001',
29     methods: ['GET', 'POST', 'PATCH', 'PUT', 'DELETE']
30 }
31 
32 app.use(cors(corsOptions))
33 
34 app.use(express.json())
35 
36 app.use(express.json())
37 
38 app.use(fileUpload())
39 
40 app.use((req, res, next) => {
41     res.header('Access-Control-Allow-Origin', 'http://localhost:3001')
42     res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
43     res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept')
44     next()
45 })
46 
47 app.use('/genre', genresRouter)
48 app.use('/organization', organizationRouter)
49 app.use('/authorization', authorizationRouter)
50 app.use('/user', userRouter)
51 app.use('/band', bandRouter)
52 app.use('/event', eventRouter)
53 app.use('/seat', seatRouter)
54 app.use('/ticket', ticketRouter)
55 app.use('/export', exportRouter)
56 app.use('/card', cardRouter)
57 
58 app.use('/', () => {
59     console.log('Hello!')
60 })
61 
62 app.listen(port, () => {
63     console.log(`Сервер працює на даному порту ${port}`)
64 })

А.2 Код файлу, який містить маршрути для експорту даних export.js

1 const express = require('express')
2 const router = express.Router()
3 const mongoose = require('mongoose')
4 const Event = require('../models/Event')
5 const Seat = require('../models/Seat')
6 const xlsx = require('xlsx')
7 const fs = require('fs')
8 const path = require('path')
9 const Band = require("../models/Band")
10 const User = require("../models/User")
11 const Ticket = require("../models/Ticket")
12 
13 router.get('/event', async (req, res) => {
14     try {
15         const events = await Event.find().populate('genre').populate('band').populate('seats').exec()
16 
17         const workbook = xlsx.utils.book_new()
18 
19         const eventSheetData = events.map(event => ({
20             "Назва": event.name,
21             "Опис": event.description,
22             "Жанр": event.genre ? event.genre.name : '',
23             "Локація": event.location,
24             "Гурт": event.band ? event.band.name : '',
25             "Дата": event.date,
26             "Кількість місць": event.seatCount
27         }))
28         const eventSheet = xlsx.utils.json_to_sheet(eventSheetData)
29         xlsx.utils.book_append_sheet(workbook, eventSheet, 'Events')
30 
31         let seatSheetData = []
32         events.forEach(event => {
33             const eventSeats = event.seats.map(seat => ({
34                 "Назва": event.name,
35                 "Тип": seat.seatType,
36                 "Ціна": seat.price
37             }))
38             seatSheetData = seatSheetData.concat(eventSeats)
39         })
40 
41         const seatSheet = xlsx.utils.json_to_sheet(seatSheetData)
42         xlsx.utils.book_append_sheet(workbook, seatSheet, 'Seats')
43 
44         const filePath = path.join(__dirname, '..', 'exports', 'events_and_seats.xlsx')
45         xlsx.writeFile(workbook, filePath)
46 
47         res.setHeader('Content-Disposition', 'attachment; filename="events_and_seats.xlsx"')
48         res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
49         res.sendFile(filePath)
50     } catch (err) {
51         res.status(500).json({ message: err.message })
52     }
53 })
54 
55 router.get('/bands', async (req, res) => {
56     try {
57         const bands = await Band.find().populate('events').populate('genre').exec()
58 
59         const workbook = xlsx.utils.book_new()
60 
61         const bandSheetData = bands.map(band => ({
62             "Назва": band.name,
63             "Опис": band.description,
64             "Жанр": band.genre ? band.genre.name : 'N/A',
65             "Події": band.events.map(event => event.name).join(', ')
66         }))
67 
68         const bandSheet = xlsx.utils.json_to_sheet(bandSheetData)
69         xlsx.utils.book_append_sheet(workbook, bandSheet, 'Bands')
70 
71         const filePath = path.join(__dirname, '..', 'exports', 'bands.xlsx')
72         xlsx.writeFile(workbook, filePath)
73 
74         res.setHeader('Content-Disposition', 'attachment; filename="bands.xlsx"')
75         res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
76         res.sendFile(filePath)
77     } catch (err) {
78         res.status(500).json({ message: err.message })
79     }
80 })
81 
82 router.get('/users', async (req, res) => {
83     try {
84         const users = await User.find().populate('tickets').exec()
85         const workbook = xlsx.utils.book_new()
86         const userSheetData = users.map(user => {
87             let roleTranslation
88             switch (user.role) {
89                 case 'admin':
90                     roleTranslation = 'Адміністратор'
91                     break
92                 case 'user':
93                     roleTranslation = 'Користувач'
94                     break
95                 case 'member':
96                     roleTranslation = 'Член гурту'
97                     break
98                 default:
99                     roleTranslation = user.role
100             }
101 
102             return {
103                 "Ім'я": user.firstName,
104                 "Прізвище": user.lastName,
105                 "Пошта": user.email,
106                 "Роль": roleTranslation,
107                 "Квитки": user.tickets.map(ticket => ticket._id).join(', ')
108             }
109         })
110         const userSheet = xlsx.utils.json_to_sheet(userSheetData)
111         xlsx.utils.book_append_sheet(workbook, userSheet, 'Users')
112 
113         const filePath = path.join(__dirname, '..', 'exports', 'users.xlsx')
114         xlsx.writeFile(workbook, filePath)
115 
116         res.setHeader('Content-Disposition', 'attachment; filename="users.xlsx"')
117         res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
118         res.sendFile(filePath)
119     } catch (err) {
120         res.status(500).json({ message: err.message })
121     }
122 })
123 
124 module.exports = router 


А.3 Код файлу, який містить маршрути для реєстрації та авторизації користувача authorization.js

1 const express = require('express')
2 const jwt = require('jsonwebtoken')
3 const bcrypt = require('bcryptjs')
4 const router = express.Router()
5 const User = require('../models/User')
6 const authMiddleware = require('../middlewares/authMiddleware')
7 const validateRegistrationFields = require('../middlewares/validationMiddleware')
8 
9 router.post('/login', async (req, res) => {
10     try {
11         const { email, password } = req.body
12         const authResult = await authMiddleware.authenticateUser(email, password)
13 
14         if (!authResult.success) {
15             return res.status(401).send({ auth: false, token: null, message: authResult.message })
16         }
17 
18         const { user } = authResult
19 
20         const roleName = user.role
21 
22         console.log(roleName)
23 
24         const token = jwt.sign({ id: user._id, role: roleName }, process.env.JWT_SECRET, {
25             expiresIn: 86400
26         })
27 
28         console.log(token)
29 
30         res.status(200).send({ auth: true, token: token })
31     } catch (err) {
32         res.status(500).send({ message: err.message })
33     }
34 })
35 
36 router.post('/registration', validateRegistrationFields, async (req, res) => {
37     try {
38         const { firstName, lastName, email, phone, password, role } = req.body
39 
40         if (!['user', 'admin', 'member'].includes(role)) {
41             return res.status(400).send({ message: 'Невірна роль' })
42         }
43 
44         const user = new User({
45             firstName,
46             lastName,
47             email,
48             phone,
49             password: bcrypt.hashSync(password, 8),
50             role
51         })
52 
53         const newUser = await user.save()
54 
55         const roleName = newUser.role
56 
57         console.log(roleName)
58 
59         const token = jwt.sign({ id: newUser._id, role: roleName }, process.env.JWT_SECRET, {
60             expiresIn: 86400
61         })
62 
63         res.status(200).send({ auth: true, token })
64     } catch (err) {
65         res.status(500).send({ message: err.message })
66     }
67 })
68 
69 module.exports = router

А.4 Код маршруту для придбання квитку tickets.js

1 router.post('/buy', async (req, res) => {
2     const { userId, eventId, seatId, cardId } = req.body
3 
4     try {
5         const user = await User.findById(userId)
6         const event = await Event.findById(eventId)
7         const seat = await Seat.findById(seatId)
8         const card = await Card.findById(cardId)
9 
10         if (!user) {
11             return res.status(404).json({ message: 'Користувача не знайдено' })
12         }
13 
14         if (!event) {
15             return res.status(404).json({ message: 'Подію не знайдено' })
16         }
17 
18         if (!seat) {
19             return res.status(404).json({ message: 'Місце не знайдено' })
20         }
21 
22         if (!card) {
23             return res.status(404).json({ message: 'Картку не знайдено' })
24         }
25 
26         const ticket = new Ticket({
27             user: userId,
28             event: eventId,
29             seat: seatId,
30             purchaseDate: new Date().toISOString()
31         })
32 
33         await ticket.save()
34 
35         user.tickets.push(ticket._id)
36         await user.save()
37 
38         const seatTypeTranslation = {
39             funzone: 'Фан-зона',
40             vip: 'ВІП-зона'
41         }
42 
43         const qrData = `${userId}-${eventId}-${seatId}`
44 
45         console.log('QR Data:', qrData)
46 
47         const qrCode = await QRCode.toDataURL(JSON.stringify(qrData))
48 
49         console.log('QR Code:', qrCode)
50 
51         ticket.qrCode = qrCode
52         await ticket.save()
53 
54         res.status(201).json(ticket)
55     } catch (err) {
56         console.error('Error:', err)
57         res.status(500).json({ message: err.message })
58     }
59 })

А.5 Код маршруту для створення місця для певної події seats.js

1 router.post('/:eventId/create', async (req, res) => {
2     try {
3         const eventId = req.params.eventId
4 
5         if (!mongoose.Types.ObjectId.isValid(eventId)) {
6             return res.status(400).json({ message: 'Неправильний ідентифікатор події' })
7         }
8 
9         const event = await Event.findById(eventId)
10 
11         if (!event) {
12             return res.status(404).json({ message: 'Подія не знайдена' })
13         }
14 
15         const seatsData = req.body.seats
16 
17         if (!seatsData || !Array.isArray(seatsData) || seatsData.length === 0) {
18             return res.status(400).json({ message: 'Необхідно надати масив даних про місця' })
19         }
20 
21         const existingSeats = await Seat.find({ event: eventId, seatType: { $in: seatsData.map(seat => seat.seatType) } })
22         if (existingSeats.length > 0) {
23             return res.status(400).json({ message: 'Місце з цим типом вже існує для даної події' })
24         }
25 
26         const createdSeats = await Seat.create(seatsData.map(seat => ({
27             event: eventId,
28             seatType: seat.seatType,
29             price: seat.price
30         })))
31 
32         event.seats.push(...createdSeats.map(seat => seat._id))
33         await event.save()
34 
35         res.status(201).json(createdSeats)
36     } catch (err) {
37         res.status(400).json({ message: err.message })
38     }
39 })
ДОДАТОК Б
Програмний код IoT-пристрою

Б.1 Код файлу node-red-qr-code-scanner-flows.json

1 [
2     {
3         "id": "3a21838f966932fb",
4         "type": "tab",
5         "label": "Поток 1",
6         "disabled": false,
7         "info": "",
8         "env": []
9     },
10     {
11         "id": "1cf852b91020fbe8",
12         "type": "http in",
13         "z": "3a21838f966932fb",
14         "name": "",
15         "url": "/scan",
16         "method": "post",
17         "upload": false,
18         "swaggerDoc": "",
19         "x": 270,
20         "y": 340,
21         "wires": [
22             [
23                 "e58285ae4d7df6c2"
24             ]
25         ]
26     },
27     {
28         "id": "e58285ae4d7df6c2",
29         "type": "qrdecode",
30         "z": "3a21838f966932fb",
31         "name": "",
32         "x": 680,
33         "y": 340,
34         "wires": [
35             [
36                 "736fce81371c239f",
37                 "6b4b9b82cf11fa0c"
38             ]
39         ]
40     },
41     {
42         "id": "736fce81371c239f",
43         "type": "function",
44         "z": "3a21838f966932fb",
45         "name": "function",
46         "func": "if (msg.payload && msg.payload.value) {\n    const cleanedValue = msg.payload.value.replace(/\"/g, '');\n\n    const values = cleanedValue.split('-');\n\n    if (values.length === 3) {\n        const userId = values[0].trim();\n        const eventId = values[1].trim();\n        const seatId = values[2].trim();\n\n        const data = { userId, eventId, seatId };\n        \n        msg.payload = data;\n        return msg;\n    } else {\n        msg.payload = { error: 'Incorrect number of values in the payload' };\n        return msg;\n    }\n} else {\n   \n    msg.payload = { error: 'Value property is missing in the payload' };\n    return msg;\n}\n",
47         "outputs": 1,
48         "timeout": 0,
49         "noerr": 0,
50         "initialize": "",
51         "finalize": "",
52         "libs": [],
53         "x": 940,
54         "y": 340,
55         "wires": [
56             [
57                 "b1f8c5722709cdb3",
58                 "b42c7854fbbf98f5"
59             ]
60         ]
61     },
62     {
63         "id": "b1f8c5722709cdb3",
64         "type": "http response",
65         "z": "3a21838f966932fb",
66         "name": "",
67         "statusCode": "200",
68         "headers": {
69             "content-type": "application/json"
70         },
71         "x": 1400,
72         "y": 340,
73         "wires": []
74     },
75     {
76         "id": "6b4b9burl":"/scan",
82         "method": "post",
83         "upload": false,
84         "swaggerDoc": "",
85         "x": 270,
86         "y": 340,
87         "wires": [
88             [
89                 "e58285ae4d7df6c2"
90             ]
91         ]
92     },
93     {
94         "id": "e58285ae4d7df6c2",
95         "type": "qrdecode",
96         "z": "3a21838f966932fb",
97         "name": "",
98         "x": 680,
99         "y": 340,
100         "wires": [
101             [
102                 "736fce81371c239f",
103                 "6b4b9b82cf11fa0c"
104             ]
105         ]
106     },
107     {
108         "id": "736fce81371c239f",
109         "type": "function",
110         "z": "3a21838f966932fb",
111         "name": "function",
112         "func": "if (msg.payload && msg.payload.value) {\n    const cleanedValue = msg.payload.value.replace(/\"/g, '');\n\n    const values = cleanedValue.split('-');\n\n    if (values.length === 3) {\n        const userId = values[0].trim();\n        const eventId = values[1].trim();\n        const seatId = values[2].trim();\n\n        const data = { userId, eventId, seatId };\n        \n        msg.payload = data;\n        return msg;\n    } else {\n        msg.payload = { error: 'Incorrect number of values in the payload' };\n        return msg;\n    }\n} else {\n   \n    msg.payload = { error: 'Value property is missing in the payload' };\n    return msg;\n}\n",
113         "outputs": 1,
114         "timeout": 0,
115         "noerr": 0,
116         "initialize": "",
117         "finalize": "",
118         "libs": [],
119         "x": 940,
120         "y": 340,
121         "wires": [
122             [
123                 "b1f8c5722709cdb3",
124                 "b42c7854fbbf98f5"
125             ]
126         ]
127     },
128     {
129         "id": "b1f8c5722709cdb3",
130         "type": "http response",
131         "z": "3a21838f966932fb",
132         "name": "",
133         "statusCode": "200",
134         "headers": {
135             "content-type": "application/json"
136         },
137         "x": 1400,
138         "y": 340,
139         "wires": []
140     },
141     {
142         "id": "6b4b9b82cf11fa0c",
143         "type": "debug",
144         "z": "3a21838f966932fb",
145         "name": "debug 2",
146         "active": true,
147         "tosidebar": true,
148         "console": false,
149         "tostatus": false,
150         "complete": "false",
151         "statusVal": "",
152         "statusType": "auto",
153         "x": 680,
154         "y": 200,
155         "wires": []
156     },
157     {
158         "id": "b42c'tostatus": false,
159         "name": "debug 3",
160         "active": true,
161         "tosidebar": true,
162         "console": false,
163         "tostatus": false,
164         "complete": "true",
165         "targetType": "full",
166         "statusVal": "",
167         "statusType": "auto",
168         "x": 1260,
169         "y": 200,
170         "wires": []
171     }
172 ]
 
ДОДАТОК В
Програмний код клієнтської частини


В.1 Код файлу сторінки профіля користувача UserProfile.js

1   import React, { useState, useEffect } from 'react';
2   import axios from 'axios';
3   import './userprofile.css';
4   import { useParams, Link, useNavigate } from 'react-router-dom';
5   import QRCode from 'qrcode.react';
6   
7   const UserProfilePage = () => {
8       const { userId } = useParams();
9       const navigate = useNavigate();
10      const [userData, setUserData] = useState(null);
11      const [roleName, setRoleName] = useState('');
12      const [error, setError] = useState('');
13      const [activeTab, setActiveTab] = useState('profile');
14  
15      useEffect(() => {
16          const fetchUserData = async () => {
17              try {
18                  const response = await axios.get(`http://localhost:3000/user/${userId}`);
19                  setUserData(response.data);
20  
21                  const role = response.data.role;
22                  switch (role) {
23                      case 'admin':
24                          setRoleName('Адміністратор');
25                          break;
26                      case 'user':
27                          setRoleName('Користувач');
28                          break;
29                      case 'member':
30                          setRoleName('Член групи');
31                          break;
32                      default:
33                          setRoleName(role);
34                          break;
35                  }
36              } catch (error) {
37                  setError('Не вдалося отримати дані профілю користувача');
38              }
39          };
40          fetchUserData();
41      }, [userId]);
42  
43      const handleDeleteProfile = async () => {
44          const confirmed = window.confirm('Ви впевнені, що хочете видалити свій профіль?');
45          if (confirmed) {
46              try {
47                  await axios.delete(`http://localhost:3000/user/${userId}`);
48                  navigate('/login');
49              } catch (err) {
50                  setError('Не вдалося видалити профіль користувача');
51              }
52          }
53      };
54  
55      const handleExport = async (type) => {
56          try {
57              const response = await axios.get(`http://localhost:3000/export/${type}`, { responseType: 'blob' });
58              const url = window.URL.createObjectURL(new Blob([response.data]));
59              const link = document.createElement('a');
60              link.href = url;
61              link.setAttribute('download', `${type}.xlsx`);
62              document.body.appendChild(link);
63              link.click();
64              link.remove();
65          } catch (err) {
66              setError('Не вдалося експортувати дані');
67          }
68      };
69  
70      if (error) {
71          return <div className="error">Помилка: {error}</div>;
72      }
73  
74      if (!userData) {
75          return <div className="loading">Завантаження...</div>;
76      }
77  
78      return (
79          <div className="profile-container">
80              <h2 className="profile-title">Профіль користувача</h2>
81              <div className="tabs">
82                  <button
83                      className={activeTab === 'profile' ? 'active-tab' : ''}
84                      onClick={() => setActiveTab('profile')}
85                  >
86                      Профіль
87                  </button>
88                  {(userData.role === 'user' || userData.role === 'member') && (
89                      <button
90                          className={activeTab === 'tickets' ? 'active-tab' : ''}
91                          onClick={() => setActiveTab('tickets')}
92                      >
93                          Квитки
94                      </button>
95                  )}
96                  {userData.role === 'admin' && (
97                      <button
98                          className={activeTab === 'scan' ? 'active-tab' : ''}
99                          onClick={() => setActiveTab('scan')}
100                 >
101                     Сканування QR-коду
102                 </button>
103             )}
104         </div>
105         {activeTab === 'profile' && (
106             <div className="profile-details">
107                 <p><span className="detail-label">Ім'я:</span> {userData.firstName}</p>
108                 <p><span className="detail-label">Прізвище:</span> {userData.lastName}</p>
109                 <p><span className="detail-label">Електронна пошта:</span> {userData.email}</p>
110                 <p><span className="detail-label">Телефон:</span> {userData.phone}</p>
111                 <p><span className="detail-label">Роль:</span> {roleName}</p>
112                 <Link to={`/edit-profile/${userId}`} className="edit-button">Редагувати профіль</Link>
113                 <button onClick={handleDeleteProfile} className="delete-button">Видалити профіль</button>
114                 {userData.role === 'admin' && (
115                     <div className="export-section">
116                         <h3>Експорт даних</h3>
117                         <button onClick={() => handleExport('event')} className="export-button">Експортувати всі
118                             події та місця
119                         </button>
120                         <button onClick={() => handleExport('users')} className="export-button">Експортувати всіх
121                             користувачів
122                         </button>
123                         <button onClick={() => handleExport('bands')} className="export-button">Експортувати всі
124                             гурти
125                         </button>
126                     </div>
127                 )}
128             </div>
129         )}
130         {activeTab === 'tickets' && <TicketsTab userId={userId}/>}
131         {activeTab === 'scan' && <QRScan/>}
132     </div>
133 );
134 };
135  
136 const TicketsTab = ({userId}) => {
137     const [tickets, setTickets] = useState([]);
138     const [error, setError] = useState('');
139  
140     useEffect(() => {
141         const fetchTickets = async () => {
142             try {
143                 const response = await axios.get(`http://localhost:3000/ticket/${userId}`);
144                 setTickets(response.data);
145             } catch (error) {
146                 setError('Не вдалося отримати квитки');
147             }
148         };
149         fetchTickets();
150     }, [userId]);
151  
152     const downloadQRCode = async (qrCodeData) => {
153         try {
154             const response = await axios.get(qrCodeData, {responseType: 'blob'});
155             const url = window.URL.createObjectURL(new Blob([response.data]));
156             const link = document.createElement('a');
157             link.href = url;
158             link.setAttribute('download', 'ticket_qr_code.png');
159             document.body.appendChild(link);
160             link.click();
161             link.remove();
162         } catch (err) {
163             setError('Не вдалося завантажити QR-код');
164         }
165     };
166  
167     if (error) {
168         return <div className="error">Помилка: {error}</div>;
169     }
170  
171     if (tickets.length === 0) {
172         return <div className="no-tickets">Немає куплених квитків</div>;
173     }
174  
175     return (
176         <div className="tickets-container">
177             <h3>Куплені квитки</h3>
178             <div className="tickets-list">
179                 {tickets.map(ticket => (
180                     <div key={ticket._id} className="ticket-item">
181                         <p><span className="ticket-label">Подія:</span> {ticket.event.name}</p>
182                         <QRCode value={ticket.qrCode} />
183                         <button onClick={() => downloadQRCode(ticket.qrCode)} className="download-btn">Завантажити QR-код</button>
184                     </div>
185                 ))}
186             </div>
187         </div>
188     );
189 };
190  
191 const QRScan = () => {
192     const [scanResult, setScanResult] = useState(null);
193     const [error, setError] = useState(null);
194  
195     const handleFileUpload = async (event) => {
196         const fileInput = event.target;
197  
198         if (fileInput.files && fileInput.files.length > 0) {
199             const file = fileInput.files[0];
200             const formData = new FormData();
201             formData.append('qrCodeImage', file);
202             console.log(file);
203  
204             try {
205                 const response = await axios.post('http://localhost:1880/scan', file, {
206                     headers: {
207                         'Content-Type': 'multipart/form-data',
208                     },
209
210                 });
211 
212                 const userId = response.data.userId;
213                 console.log(userId);
214 
215                 const eventId = response.data.eventId;
216                 console.log(eventId);
217 
218                 const seatId = response.data.seatId;
219                 console.log(seatId);
220 
221                 const userResponse = await axios.get(`http://localhost:3000/user/${userId}`);
222                 const userInfo = userResponse.data;
223                 console.log(userInfo);
224 
225                 const eventResponse = await axios.get(`http://localhost:3000/event/${eventId}`);
226                 const eventData = eventResponse.data;
227                 console.log(eventData);
228 
229                 const seatResponse = await axios.get(`http://localhost:3000/seat/${eventId}`);
230                 const seatData = seatResponse.data;
231                 console.log(seatData);
232 
233                 const seatTypeTranslation = {
234                     funzone: 'Фан-зона',
235                     vip: 'ВІП-зона'
236                 };
237 
238                 const foundSeat = seatData.find(seat => seat._id === seatId);
239 
240                 const translatedSeatType = foundSeat ? seatTypeTranslation[foundSeat.seatType] : null;
241 
242                 try {
243                     setScanResult({
244                         firstName: userInfo.firstName,
245                         lastName: userInfo.lastName,
246                         eventName: eventData.name,
247                         seatType: translatedSeatType,
248                         seatPrice: foundSeat.price
249                     });
250 
251                     console.log('First Name: ' + scanResult.firstName);
252                     console.log('Last Name: ' + scanResult.lastName);
253                     console.log('Event Name: ' + scanResult.eventName);
254                     console.log('Seat Type: ' + scanResult.seatType);
255                     console.log('Price: ' + scanResult.seatType);
256 
257                 } catch (err) {
258                     console.log(err);
259                 }
260 
261             } catch (error) {
262                 console.error('Error uploading QR code image:', error);
263             }
264         }
265     };
266 
267     return (
268         <div className="qr-scan-container">
269             <h3>Сканування QR-коду</h3>
270             <input
271                 id="qrCodeImageInput"
272                 type="file"
273                 accept="image/*"
274                 onChange={handleFileUpload}
275             />
276             {error && <div className="error">{error}</div>}
277             {scanResult && (
278                 <div className="scan-result">
279                     <p>Отримана інформація з QR-коду:</p>
280                     <p>Користувач: {scanResult.firstName} {scanResult.lastName}</p>
281                     <p>Подія: {scanResult.eventName}</p>
282                     <p>Місце: {scanResult.seatType}</p>
283                     <p>Ціна: {scanResult.seatPrice}</p>
284                 </div>
285             )}
286         </div>
287     );
288 };
289 
290 
291 export default UserProfilePage;

В.2 Код файлу сторінки відображення події EventPage.js

  1 import React, { useState, useEffect } from 'react';
  2 import axios from 'axios';
  3 import { useParams, Link, useNavigate } from 'react-router-dom';
  4 import { jwtDecode } from 'jwt-decode';
  5 import './eventpage.css';
  6 import '../../styles/container.css';
  7 
  8 function EventPage() {
  9     const { eventId } = useParams();
 10     const [event, setEvent] = useState(null);
 11     const [seats, setSeats] = useState([]);
 12     const [error, setError] = useState('');
 13     const [purchaseError, setPurchaseError] = useState('');
 14     const [isAdmin, setIsAdmin] = useState(false);
 15     const navigate = useNavigate();
 16     
 17     useEffect(() => {
 18         // Функція для отримання деталей події
 19         const fetchEvent = async () => {
 20             try {
 21                 const response = await axios.get(`http://localhost:3000/event/${eventId}`);
 22                 setEvent(response.data);
 23             } catch (err) {
 24                 setError('Не вдалося отримати інформацію про подію');
 25             }
 26         };
 27 
 28         // Функція для отримання деталей місць
 29         const fetchSeats = async () => {
 30             try {
 31                 const response = await axios.get(`http://localhost:3000/seat/${eventId}`);
 32                 setSeats(response.data);
 33             } catch (err) {
 34                 setError('Не вдалося отримати інформацію про місця');
 35             }
 36         };
 37 
 38         fetchEvent();
 39         fetchSeats();
 40 
 41         // Перевірка чи користувач є адміністратором
 42         const token = localStorage.getItem('token');
 43         if (token) {
 44             const decodedToken = jwtDecode(token);
 45             if (decodedToken.role === 'admin') {
 46                 setIsAdmin(true);
 47             }
 48         }
 49     }, [eventId]);
 50     
 51     // Функція для видалення події
 52     const handleDeleteEvent = async () => {
 53         const confirmed = window.confirm('Ви впевнені, що хочете видалити цю подію?');
 54         if (confirmed) {
 55             try {
 56                 await axios.delete(`http://localhost:3000/event/${eventId}`);
 57                 navigate('/events');
 58             } catch (err) {
 59                 setError('Не вдалося видалити подію');
 60             }
 61         }
 62     };
 63 
 64     // Функція для видалення місця
 65     const handleDeleteSeat = async (seatId) => {
 66         const confirmed = window.confirm('Ви впевнені, що хочете видалити це місце?');
 67         if (confirmed) {
 68             try {
 69                 await axios.delete(`http://localhost:3000/seat/${seatId}`);
 70                 setSeats(seats.filter(seat => seat._id !== seatId));
 71             } catch (err) {
 72                 setError('Не вдалося видалити місце');
 73             }
 74         }
 75     };
 76 
 77     // Функція для купівлі квитка
 78     const handlePurchaseTicket = () => {
 79         if (seats.length === 0) {
 80             setPurchaseError('На жаль, зараз немає вільних місць');
 81         } else {
 82             navigate(`/purchase/${eventId}`);
 83         }
 84     };
 85 
 86     // Функція для перекладу типів місць на українську
 87     const translateSeatType = (seatType) => {
 88         switch (seatType) {
 89             case 'funzone':
 90                 return 'Фан-зона';
 91             case 'vip':
 92                 return 'VIP-зона';
 93             default:
 94                 return seatType;
 95         }
 96     };
 97 
 98     // Відображення повідомлення про помилку, якщо вона виникла
 99     if (error) {
100         return <div className="error">{error}</div>;
101     }
102 
103     // Відображення повідомлення про завантаження даних
104     if (!event) {
105         return <div className="loading">Завантаження...</div>;
106     }
107 
108     return (
109         <div className='container'>
110             <div className="event-page">
111                 <h2>{event.name}</h2>
112                 <div className="event-details">
113                     <p><strong>Опис:</strong> {event.description}</p>
114                     <p><strong>Жанр:</strong> {event.genre?.name}</p>
115                     <p><strong>Місце проведення:</strong> {event.location}</p>
116                     <p><strong>Гурт:</strong> {event.band?.name}</p>
117                     <p><strong>Дата:</strong> {event.date}</p>
118                     <p><strong>Кількість місць:</strong> {event.seatCount}</p>
119                 </div>
120                 <div className="seats-list">
121                     <h3>Вільні місця</h3>
122                     {seats.length > 0 ? (
123                         <div className="seats-grid">
124                             {seats.map((seat) => (
125                                 <div key={seat._id} className="seat-card">
126                                     <p><strong>Тип місця:</strong> {translateSeatType(seat.seatType)}</p>
127                                     <p><strong>Ціна:</strong> {seat.price} грн</p>
128                                     {isAdmin && (
129                                         <div className="seat-actions">
130                                             <Link to={`/edit-seat/${eventId}/${seat._id}`} className="edit-seat-btn">Редагувати</Link>
131                                             <button onClick={() => handleDeleteSeat(seat._id)} className="delete-seat-btn">Видалити</button>
132                                         </div>
133                                     )}
134                                 </div>
135                             ))}
136                         </div>
137                     ) : (
138                         <p>Немає вільних місць</p>
139                     )}
140                 </div>
141                 {isAdmin && (
142                     <div className="admin-actions">
143                         <Link to={`/edit-event/${eventId}`} className="edit-event-btn">Редагувати подію</Link>
144                         <button onClick={handleDeleteEvent} className="delete-event-btn">Видалити подію</button>
145                         <Link to={`/create-seat/${eventId}`} className="create-seat-btn">Створити місце</Link>
146                     </div>
147                 )}
148                 {!isAdmin && (
149                     <div>
150                         <button onClick={handlePurchaseTicket} className="purchase-ticket-btn">Купити квиток</button>
151                         {purchaseError && <div className="purchase-error">{purchaseError}</div>}
152                     </div>
153                 )}
154             </div>
155         </div>
156     );
157 }
158 
159 export default EventPage;

В.3 Код сторінки покупки квитка PurchaseTicketPage.js

  1 import React, { useState, useEffect } from 'react';
  2 import axios from 'axios';
  3 import { useParams, useNavigate } from 'react-router-dom';
  4 import { jwtDecode } from 'jwt-decode';
  5 import './buyticket.css';
  6 import '../../styles/container.css';
  7 
  8 function PurchaseTicketPage() {
  9     const { eventId } = useParams();
 10     const [user, setUser] = useState({
 11         firstName: '',
 12         lastName: '',
 13         email: '',
 14         userId: ''
 15     });
 16     const [event, setEvent] = useState(null);
 17     const [seats, setSeats] = useState([]);
 18     const [selectedSeat, setSelectedSeat] = useState('');
 19     const [cardNumber, setCardNumber] = useState('');
 20     const [expiryDate, setExpiryDate] = useState('');
 21     const [cvv, setCVV] = useState('');
 22     const [cardholderName, setCardholderName] = useState('');
 23     const [error, setError] = useState('');
 24     const [cards, setCards] = useState([]);
 25     const [showCardForm, setShowCardForm] = useState(false);
 26     const navigate = useNavigate();
 27     const [cardId, setCardId] = useState('');
 28     
 29     useEffect(() => {
 30         const fetchUserData = async (userId) => {
 31             try {
 32                 const response = await axios.get(`http://localhost:3000/user/${userId}`);
 33                 const userData = response.data;
 34                 console.log('User data from API:', userData);
 35                 setUser({
 36                     firstName: userData.firstName || '',
 37                     lastName: userData.lastName || '',
 38                     email: userData.email || '',
 39                     userId: userData._id || ''
 40                 });
 41             } catch (err) {
 42                 setError('Не вдалося отримати інформацію про користувача');
 43             }
 44         };
 45 
 46         const fetchUserCards = async (userId) => {
 47             try {
 48                 const response = await axios.get(`http://localhost:3000/card/${userId}`);
 49                 setCards(response.data);
 50             } catch (err) {
 51                 setError('Не вдалося отримати інформацію про картки');
 52             }
 53         };
 54 
 55         const token = localStorage.getItem('token');
 56         console.log('Token from localStorage:', token);
 57 
 58         if (token) {
 59             const decodedToken = jwtDecode(token);
 60             console.log('Decoded token:', decodedToken);
 61             const userId = decodedToken.id || decodedToken.sub;
 62             console.log('User ID:', userId);
 63             if (userId) {
 64                 fetchUserData(userId);
 65                 fetchUserCards(userId);
 66             }
 67         }
 68 
 69         const fetchEvent = async () => {
 70             try {
 71                 const response = await axios.get(`http://localhost:3000/event/${eventId}`);
 72                 setEvent(response.data);
 73             } catch (err) {
 74                 setError('Не вдалося отримати інформацію про подію');
 75             }
 76         };
 77 
 78         const fetchSeats = async () => {
 79             try {
 80                 const response = await axios.get(`http://localhost:3000/seat/${eventId}`);
 81                 setSeats(response.data);
 82             } catch (err) {
 83                 setError('Не вдалося отримати інформацію про місця');
 84             }
 85         };
 86 
 87         fetchEvent();
 88         fetchSeats();
 89     }, [eventId]);
 90 
 91     const handleSubmit = async (e) => {
 92         console.log(user.userId,
 93             user.firstName,
 94             user.lastName,
 95             user.email,
 96             eventId, selectedSeat,
 97             cardNumber,
 98             expiryDate,
 99             cvv,
100             cardholderName);
101         e.preventDefault();
102         try {
103             const response = await axios.post('http://localhost:3000/ticket/buy', {
104                 userId: user.userId,
105                 firstName: user.firstName,
106                 lastName: user.lastName,
107                 email: user.email,
108                 eventId,
109                 seatId: selectedSeat,
110                 cardId: cardId,
111                 cardNumber,
112                 expiryDate,
113                 cvv,
114                 cardholderName
115             });
116             console.log(response.data);
117             navigate(`/profile/${user.userId}`);
118         } catch (err) {
119             setError('Не вдалося придбати квиток');
120             console.error(err);
121         }
122     };
123 
124     const handleAddCard = async () => {
125         try {
126             const response = await axios.post('http://localhost:3000/card/create', {
127                 userId: user.userId,
128                 cardNumber,
129                 expiryDate,
130                 cvv,
131                 cardholderName
132             });
133             console.log('Card added:', response.data);
134             setCards([...cards, response.data]);
135             setShowCardForm(false);
136             setCardNumber('');
137             setExpiryDate('');
138             setCVV('');
139             setCardholderName('');
140             setCardId(response.data._id);
141         } catch (err) {
142             setError('Не вдалося додати картку');
143             console.error(err);
144         }
145     };
146 
147     const translateSeatType = (seatType) => {
148         switch (seatType) {
149             case 'funzone':
150                 return 'Фан-зона';
151             case 'vip':
152                 return 'ВІП-зона';
153             default:
154                 return seatType;
155         }
156     };
157 
158     return (
159         <div className='container'>
160             <div className="purchase-ticket-page">
161                 <h2>Купівля квитка</h2>
162                 {error && <div className="error">{error}</div>}
163                 <form onSubmit={handleSubmit}>
164                     <div className="form-group">
165                         <label htmlFor="firstName">Ім'я:</label>
166                         <input
167                             type="text"
168                             id="firstName"
169                             value={user.firstName}
170                             onChange={(e) => setUser({ ...user, firstName: e.target.value })}
171                             required
172                         />
173                     </div>
174                     <div className="form-group">
175                         <label htmlFor="lastName">Прізвище:</label>
176                         <input
177                             type="text"
178                             id="lastName"
179                             value={user.lastName}
180                             onChange={(e) => setUser({ ...user, lastName: e.target.value })}
181                             required
182                         />
183                     </div>
184                     <div className="form-group">
185                         <label htmlFor="email">Електронна пошта:</label>
186                         <input
187                             type="email"
188                             id="email"
189                             value={user.email}
190                             onChange={(e) => setUser({ ...user, email: e.target.value })}
191                             required
192                         />
193                     </div>
194                     {event && (
195                         <div className="event-info">
196                             <p><strong>Подія:</strong> {event.name}</p>
197                         </div>
198                     )}
199                     <div className="form-group">
200                         <label htmlFor="seat">Місце:</label>
201                         <select
202                             id="seat"
203                             value={selectedSeat}
204                             onChange={(e) => setSelectedSeat(e.target.value)}
205                             required
206                         >
207                             <option value="">Оберіть місце</option>
208                             {seats.map((seat) => (
209                                 <option key={seat._id} value={seat._id}>
210                                     {translateSeatType(seat.seatType)} - {seat.price} грн
211                                 </option>
212                             ))}
213                         </select>
214                     </div>
215                     {cards.length > 0 ? (
216                         <div className="form-group">
217                             <label htmlFor="savedCards">Збережені картки:</label>
218                             <select
219                                 id="savedCards"
220                                 onChange={(e) => {
221                                     const selectedCard = cards.find(card => card._id === e.target.value);
222                                     if (selectedCard) {
223                                         setCardNumber(selectedCard.cardNumber);
224                                         setExpiryDate(selectedCard.expiryDate);
225                                         setCVV(selectedCard.cvv);
226                                         setCardholderName(selectedCard.cardholderName);
227                                         setCardId(selectedCard._id);
228                                     }
229                                 }}
230                             >
231                                 <option value="">Оберіть картку</option>
232                                 {
233                                 cards.map(card => (
234                                     <option key={card._id} value={card._id}>
235                                         {card.cardNumber} - {card.cardholderName}
236                                     </option>
237                                 ))}
238                             </select>
239                         </div>
240                     ) : (
241                         <button type="button" onClick={() => setShowCardForm(true)}>Додати картку</button>
242                     )}
243                     {showCardForm && (
244                         <>
245                             <div className="form-group">
246                                 <label htmlFor="cardNumber">Номер картки:</label>
247                                 <input
248                                     type="text"
249                                     id="cardNumber"
250                                     value={cardNumber}
251                                     onChange={(e) => setCardNumber(e.target.value)}
252                                     required
253                                 />
254                             </div>
255                             <div className="form-group">
256                                 <label htmlFor="expiryDate">Термін дії:</label>
257                                 <input
258                                     type="text"
259                                     id="expiryDate"
260                                     value={expiryDate}
261                                     onChange={(e) => setExpiryDate(e.target.value)}
262                                     required
263                                 />
264                             </div>
265                             <div className="form-group">
266                                 <label htmlFor="cvv">CVV:</label>
267                                 <input
268                                     type="text"
269                                     id="cvv"
270                                     value={cvv}
271                                     onChange={(e) => setCVV(e.target.value)}
272                                     required
273                                 />
274                             </div>
275                             <div className="form-group">
276                                 <label htmlFor="cardholderName">Ім'я власника картки:</label>
277                                 <input
278                                     type="text"
279                                     id="cardholderName"
280                                     value={cardholderName}
281                                     onChange={(e) => setCardholderName(e.target.value)}
282                                     required
283                                 />
284                             </div>
285                             <button type="button" onClick={handleAddCard}>Додати картку</button>
286                         </>
287                     )}
288                     <button type="submit">Купити квиток</button>
289                 </form>
290             </div>
291         </div>
292     );
293 }
294 
295 export default PurchaseTicketPage;

В.4 Код файлу відображення шапки сайту Header.js

1  import React, { useEffect, useState } from 'react';
2  import './header.css';
3  import { Link, useNavigate } from 'react-router-dom';
4  import {jwtDecode} from 'jwt-decode';
5  
6  function Header() {
7      const [userId, setUserId] = useState(null);
8      const [userRole, setUserRole] = useState(null);
9      const token = localStorage.getItem('token');
10     const navigate = useNavigate();
11 
12     useEffect(() => {
13         if (token) {
14             const decodedToken = jwtDecode(token);
15             const userIdFromToken = decodedToken.id;
16             const userRoleFromToken = decodedToken.role;
17             if (userIdFromToken) {
18                 setUserId(userIdFromToken);
19             }
20             if (userRoleFromToken) {
21                 setUserRole(userRoleFromToken);
22             }
23         }
24     }, [token]);
25 
26     const handleLogout = () => {
27         localStorage.removeItem('token');
28         navigate('/login');
29     };
30 
31     return (
32         <header className="Header">
33             <div className="container">
34                 <Link to="/" className="logo">BandBridge</Link>
35                 <nav>
36                     <ul>
37                         {!token && (
38                             <>
39                                 <li><Link to="/login">Логін</Link></li>
40                                 <li><Link to="/registration">Реєстрація</Link></li>
41                                 <li><Link to="/bands">Гурти</Link></li>
42                                 <li><Link to="/events">Концерти</Link></li>
43                             </>
44                         )}
45                         {token && (
46                             <>
47                                 {userId && (
48                                     <li><Link to={`/profile/${userId}`}>Профіль</Link></li>
49                                 )}
50                                 <li><Link to="/bands">Гурти</Link></li>
51                                 <li><Link to="/events">Концерти</Link></li>
52                                 {userRole === 'admin' && (
53                                     <li><Link to="/genres">Жанри</Link></li>
54                                 )}
55                                 <li><span onClick={handleLogout} className='exit-login-btn'>Вихід</span></li>
56                             </>
57                         )}
58                     </ul>
59                 </nav>
60             </div>
61         </header>
62     );
63 }
64 
65 export default Header;
